# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2018, Tom Rothamel
# This file is distributed under the same license as the Ren'Py Visual Novel Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Ren'Py Visual Novel Engine 7.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-15 21:35+0900\n"
"PO-Revision-Date: 2025-07-23 22:29+0900\n"
"Last-Translator: kyouryuukunn <akakyouryuu@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.2.4\n"

#: ../../source/layeredimage.rst:3
msgid "Layered Images"
msgstr "レイヤー画像"

#: ../../source/layeredimage.rst:5
msgid ""
"When a sprite-set gets to a certain level of complexity, defining every "
"possible combination may become unwieldy. For example, a character with 4 "
"outfits, 4 hairstyles, and 6 emotions already has 96 possible combinations. "
"Creating static images for each possible combination would consume a lot of "
"disk space and programmer time."
msgstr ""
"スプライトの組み合わせがある程度複雑になると、すべての可能な組み合わせの定義"
"は難しくなります。例えば4つの服装と4つの髪型、6つの表情のキャラクターの組み合"
"わせはすでに 96 組あります。すべての可能な組み合わせの静止画像作成は多くの"
"ディスクスペースとプログラマーの時間を消費します。"

#: ../../source/layeredimage.rst:11
msgid ""
"To address this use case, Ren'Py introduces a way of defining an image "
"consisting of multiple sprites, organized in layers. (For the purpose of "
"this, consider layers to be the layers in a paint program like Photoshop or "
"the GIMP, and not the layers used elsewhere in Ren'Py.) Elements of these "
"layers can be selected by :ref:`attributes <concept-image>` provided to the "
"image, or by conditions that are evaluated at runtime."
msgstr ""
"このような状況に対処するため、Ren'Py にはレイヤーに分けられた複数のスプライト"
"で構成される画像を定義する方法があります(ここで言うレイヤーは Photoshop や"
"GIMP のようなペイントソフトでのレイヤーであり、Ren'Py の他の場所で語られてい"
"るようなレイヤーではありません)。これらのレイヤーの要素はその画像に指定され"
"た :ref:`属性 <concept-image>` や実行時に評価された条件によって選択されます。"

#: ../../source/layeredimage.rst:18
msgid ""
"These images can be declared using the ``layeredimage`` statement, using a "
"specific language. The :func:`LayeredImage` object is its Python "
"alternative, it's not a :doc:`displayable <displayables>` but can be "
"assigned to an image statement and used like one."
msgstr ""
"これらの画像は特別な言語により ``layerdimage`` ステートメントを使用して宣言で"
"きます。レイヤー画像の定義をより簡単に定義するため、 Ren'Py には "
"``layerdimage`` ステートメントがあります。 :func:`LayerdImage` オブジェクトは"
"その python に相当するものであり、 :doc:`displayable <displayables>` ではあり"
"ませんが、 image ステートメントに代入して画像のように使用出来ます。"

#: ../../source/layeredimage.rst:23
msgid "The bottom of this page contains advice and examples of use."
msgstr "このページの末尾には使用に対するアドバイスと例があります。"

#: ../../source/layeredimage.rst:26
msgid "Defining Layered Images"
msgstr "レイヤー画像の定義"

#: ../../source/layeredimage.rst:28
msgid ""
"The language used to define layered images consists of only a few "
"statements, to introduce the layers. Here is an example which, while not "
"making much practical sense, is technically correct and outlines the "
"layeredimage syntax::"
msgstr ""
"レイヤー画像を定義するのに使用される言語はレイヤーを導入する僅かなステートメ"
"ントで構成されます。こちらは実用的な意味はあまりありませんが、技術的には正し"
"く、レイヤー画像の構文概要を示す例です。 ::"

#: ../../source/layeredimage.rst:70
msgid "Layeredimage"
msgstr "Layeredimage"

#: ../../source/layeredimage.rst:72
msgid ""
"The ``layeredimage`` statements opens the show. The statement is part of the "
"Ren'Py script language, and runs at :ref:`init time <init-phase>`. Like the :"
"ref:`atl-image-statement`, it takes an image name and opens a block, "
"although what's in the block differs greatly. The image name may contain "
"spaces, just like any other image name in Ren'Py."
msgstr ""
"まず、 ``layeredimage`` ステートメントを紹介します。このステートメントは "
"Ren'Py スクリプト言語の一部であり、 :ref:`初期化時 <init-phase>` に実行されま"
"す。 :ref:`atl-image-statement` と同様に、画像名を受け取ってブロックを開きま"
"すが、ブロックの中身は大きく異なっています。画像名には、 Ren'Py の他の画像名"
"と同じように、スペースを含めるられます。"

#: ../../source/layeredimage.rst:78
msgid ""
"Inside the block will fit the statements described further down, as well as "
"the following optional properties."
msgstr ""
"ブロックの中には後述するステートメントと次の任意のプロパティーが収まります。"

#: ../../source/layeredimage.rst:86 ../../source/inc/li_ff:31
msgid "`image_format`"
msgstr "`image_format`"

#: ../../source/layeredimage.rst:82
msgid ""
"When a given image is a string, and this is supplied, the image name is "
"interpolated into `image_format` to make an image file. For example, "
"\"sprites/eileen/{image}.png\" will look for the image in a subdirectory of "
"sprites. (This is not used by auto groups, which look for defined images and "
"not for image files.)"
msgstr ""
"文字列で画像が与えられており、かつこのプロパティーが与えられていると、"
"`image_format` にその画像名が補完され、画像ファイルになります。例えば、 "
"\"sprites/eileen/{image}.png\" ならsptritesのサブディレクトリーからその画像を"
"探します ( 自動グループは画像ファイルではなく定義された画像を探すためこれは自"
"動グループでは使用されません)。"

#: ../../source/layeredimage.rst:91
msgid "`format_function`"
msgstr "`format_function`"

#: ../../source/layeredimage.rst:89
msgid ""
"A function that is used instead of :func:`layeredimage.format_function` to "
"format the image information into a displayable, during the image definition "
"at init time."
msgstr ""
":func:`layeredimage.format_function` の代わりに初期化時の画像定義中に使用して"
"画像の情報を displayable 形式にする関数です。"

#: ../../source/layeredimage.rst:99
msgid "`attribute_function`"
msgstr "`attribute_function`"

#: ../../source/layeredimage.rst:94
msgid ""
"A function or callable that is used to tweak what attributes end up being "
"displayed. It is called with a set of attributes supplied to the image, and "
"should return the set of attributes that should be used to select layers. It "
"can be used to express complex dependencies between attributes, or to select "
"attributes at random. See :ref:`attribute-selection-process` for more "
"information about when and how this is called."
msgstr ""
"表示される属性を調整する関数やコールバックです。画像に渡される属性の set で呼"
"び出され、レイヤーの選択に使用される属性の set を返します。属性間の複雑な依存"
"関係を表現したり、属性をランダムに選択するのに使用出来ます。いつどのように呼"
"び出されるかは :ref:`attribute-selection-process` を参照してください。"

#: ../../source/layeredimage.rst:104 ../../source/layeredimage.rst:146
#: ../../source/layeredimage.rst:183 ../../source/layeredimage.rst:240
msgid "`at`"
msgstr "`at`"

#: ../../source/layeredimage.rst:102
msgid ""
"A transform or list of transforms that are applied to the layered image. It "
"can also be used in the form of ``at transform:`` followed by an ATL block, "
"to define an ATL transform which will be applied to the layeredimage."
msgstr ""
"指定されレイヤー画像に適用される transform または transform のリスト。 ``at "
"transform:`` の後に ATL ブロックが続く形式で使用して、 レイヤー画像に適用され"
"る ATL transform を定義もできます。"

#: ../../source/layeredimage.rst:108 ../../source/layeredimage.rst:140
#: ../../source/layeredimage.rst:178 ../../source/layeredimage.rst:235
msgid ":ref:`transform properties <transform-properties>`"
msgstr ":ref:`transform プロパティー <transform-properties>`"

#: ../../source/layeredimage.rst:107 ../../source/layeredimage.rst:139
msgid ""
"If given, these are used to construct a transform that is applied to the "
"displayable."
msgstr ""
"与えられれば、 Displayable に適用される transform を構築するのに使用されま"
"す。"

#: ../../source/layeredimage.rst:119
msgid "`offer_screen`"
msgstr "`offer_screen`"

#: ../../source/layeredimage.rst:111
msgid ""
"If this is True, the layeredimage will place its children, and size its "
"children with variable size, like it was given an area matching the whole "
"screen of the game. If it is False, the said behaviors will be done while "
"taking into account the available area, which for example will be smaller in "
"an hbox containing other elements, and the display of the layeredimage will "
"not be consistent every time it is shown."
msgstr ""
"これが True ならゲームの画面全体と同じ領域が与えられたかのようにレイヤー画像"
"はその子を配置し、可変サイズの子のサイズを合わせます。 False なら、利用可能な"
"領域を考慮しながらこれらの動作が行われ、例えば他の要素を含む hbox では小さく"
"なり、レイヤー画像の表示は表示されるたびに一貫しなくなります。"

#: ../../source/layeredimage.rst:118
msgid ""
"If None, the default, falls back to :var:`config.layeredimage_offer_screen`, "
"which defaults to True."
msgstr ""
"None の場合、デフォルトの :var:`config.layeredimage_offer_screen` に戻りま"
"す。これはデフォルトでは True です。"

#: ../../source/layeredimage.rst:122
msgid "Always"
msgstr "Always"

#: ../../source/layeredimage.rst:124
msgid ""
"The ``always`` statement declares an image that is always shown inside the "
"layeredimage, and which will not be attached to an attribute. It must be "
"supplied a displayable, and can also take properties. Both can be placed on "
"the same line or inside a block. The displayable may be declared using the "
"word ``image:`` followed by an ATL block, which is similar to the :ref:`atl-"
"image-statement`."
msgstr ""
"``always`` ステートメントは常にレイヤー画像に表示され、属性には所属しない画像"
"を宣言します。 displayable が与えられなければならず、プロパティーも受け取れま"
"す。両方を同じ行にもブロック内にも配置できます。 Displayable は ``image:`` に"
"続く ATL ブロックを使用しても宣言でき、これは :ref:`atl-image-statement` と同"
"じです。"

#: ../../source/layeredimage.rst:131
msgid "The ``always`` statement takes the following properties:"
msgstr "``always`` ステートメントは次のプロパティーを受け取ります。 :"

#: ../../source/layeredimage.rst:136 ../../source/layeredimage.rst:174
#: ../../source/layeredimage.rst:231
msgid "`when`"
msgstr "`when`"

#: ../../source/layeredimage.rst:134 ../../source/layeredimage.rst:229
#, fuzzy
msgid ""
"An :ref:`when` expression in parentheses. If this is given, this layer is "
"only displayed if the set of attributes that are called on the layeredimage "
"satisfy the when expression."
msgstr ""
"属性の名前の文字列または文字列リストです。これがあれば、このレイヤーはそのす"
"べての属性名が与えられなければ表示されません。"

#: ../../source/layeredimage.rst:143
msgid ""
"A transform or list of transforms that are applied to the provided "
"displayable. It can also be used in the form of ``at transform:`` followed "
"by an ATL block, to define an ATL transform which will be applied to the "
"displayable."
msgstr ""
"指定された displayable に適用される transform または transform のリスト。 "
"``at transform:`` の後に ATL ブロックが続く形式で使用して、 displayable に適"
"用される ATL transform を定義もできます。"

#: ../../source/layeredimage.rst:149
msgid "If"
msgstr "If"

#: ../../source/layeredimage.rst:151
msgid ""
"The ``if`` statement (or more fully the if-elif-else statement) allows you "
"to supply one or more conditions that are evaluated at runtime. Each "
"condition is associated with a displayable, with the first true condition "
"being the one that is shown. If no condition is true, the ``else`` layer is "
"shown if given."
msgstr ""
"``if`` ステートメント (または if-elif-else ステートメント) には実行時に評価さ"
"れる 1 つ以上の条件を渡せられます。各条件は Displayable に関連付けられ、最初"
"に True となる条件のものが表示されます。 True となる条件がなく、 ``else`` レ"
"イヤーがあれば、それが表示されます。"

#: ../../source/layeredimage.rst:157
msgid "A more complete example of an ``if`` statement might look like::"
msgstr "``if`` ステートメントのより完全な例は次のようになります。 ::"

#: ../../source/layeredimage.rst:168
msgid ""
"Each clause must be given a displayable, which can be done with the ``image:"
"`` syntax described earlier. It can also be given these properties:"
msgstr ""
"各節には displayable が与えられなければならず、前述の ``image`` 構文で出来ま"
"す。次のプロパティーも与えられます。 :"

#: ../../source/layeredimage.rst:172
#, fuzzy
msgid ""
"An :ref:`when` expression in parentheses. If this is given, this condition "
"is only displayed if the set of attributes that are called on the "
"layeredimage satisfy the when expression."
msgstr ""
"属性の名前の文字列または文字列リストです。これがあれば、このレイヤーはそのす"
"べての属性名が与えられなければ表示されません。"

#: ../../source/layeredimage.rst:177
msgid ""
"If present, these are used to construct a transform that is applied to the "
"displayable."
msgstr ""
"与えられれば、 Displayable に適用される transform を構築するのに使用されま"
"す。"

#: ../../source/layeredimage.rst:181
msgid ""
"A transform or list of transforms that are applied to the displayable. It "
"can also be used in the form of ``at transform:`` followed by an ATL block, "
"to define an ATL transform which will be applied to the displayable."
msgstr ""
"displayable に適用される transform または transform のリスト。 ``at "
"transform:`` の後に ATL ブロックが続く形式で使用して、 displayable に適用され"
"る ATL transform を定義もできます。"

#: ../../source/layeredimage.rst:185
msgid ""
"The ``if`` statement is transformed to a :func:`ConditionSwitch` when the "
"``layeredimage`` statement runs."
msgstr ""
"``if`` ステートメントは ``layerdimage`` ステートメント実行時に :func:"
"`ConditionSwitch` に変換されます。"

#: ../../source/layeredimage.rst:190
msgid ""
"Sets the value of `predict_all` for the ConditionSwitches produced by "
"layeredimages' ``if`` statements."
msgstr ""
"`predict_all` の値をレイヤー画像の ``if`` ステートメントで生成された "
"ConditionSwitch に対して設定します。"

#: ../../source/layeredimage.rst:193
msgid ""
"When ``predict_all`` is not true, changing the condition of the if statement "
"should be avoided while the layered image is shown or about to be shown, as "
"it would lead to an unpredicted image load. It's intended for use for "
"character customization options that don't change often."
msgstr ""
"``predict_all`` が True でなければ、レイヤー画像が表示されている、またはまさ"
"に表示されるときは ``if`` ステートメントの条件の変更は避け、予測不能な画像の"
"読み込みを避けるべきです。これはめったに変更されない character のカスタマイズ"
"オプションでの使用を意図しています。"

#: ../../source/layeredimage.rst:199
msgid "Attribute"
msgstr "Attribute"

#: ../../source/layeredimage.rst:201
msgid ""
"The ``attribute`` statement adds a displayable that is part of the resulting "
"image when the given attribute is used to display it. For example, using the "
"previous example, calling ``show augustina dress`` will cause the "
"\"augustina_dress\" to be shown as part of the \"augustina\" image."
msgstr ""
"``attribute`` ステートメントは、指定の属性が使用されたときに表示にされる最終"
"的な画像の一部となる Displayable を追加します。例えば前述の例では、 ``show "
"augustina dress`` を呼び出すと、 \"augustina_dress\" が \"augustina\" 画像の"
"一部として表示されます。"

#: ../../source/layeredimage.rst:206
#, fuzzy
msgid ""
"An ``attribute`` clause takes an attribute name, which is one word (more "
"precisely, one image name component, see :ref:`elements-of-statements`). It "
"can also take two keywords. The ``default`` keyword indicates that the "
"attribute should be present by default unless an attribute in the same group "
"is called. The ``null`` keyword prevents this clause from getting attached a "
"displayable, which can be useful for bookkeeping and to build conditional "
"display conditions using `when`, `attribute_function`, :var:`config."
"adjust_attributes` or :var:`config.default_attribute_callbacks`."
msgstr ""
"``attribute`` 節は属性名を受け取り、それは1つの単語(正確には画像名の要素の一"
"つです。 :ref:`elements-of-statements` 参照)です。さらに 2 つのキーワードも受"
"け取れます。 ``default`` キーワードは同じグループの属性が呼ばれていなければデ"
"フォルトで与えられる属性であることを示します。 ``null`` キーワードはこの節が "
"Displayable を所得しないようにます。これは bookkeeping や `when` や "
"`attribute_function`, :var:`config.adjust_attributes`, :var:`config."
"default_attribute_callbacks` を使用して表示する条件を構築するのに便利です。"

#: ../../source/layeredimage.rst:215
msgid ""
"The same attribute name can be used in multiple ``attribute`` clauses (and "
"in auto-defined attributes as part of ``auto`` groups, more about that "
"later), with all the corresponding displayables being shown at the same time "
"(the `when` property can tweak this)."
msgstr ""
"同じ属性名を複数の ``attribute`` 節 ( および ``auto`` グループの一部としての"
"自動定義の属性 ) で使用して、対応するすべての Dsiplayable を同時に表示できま"
"す ( `when` プロパティーでこれを調整出来ます)。"

#: ../../source/layeredimage.rst:220
msgid ""
"A displayable can be given, optionally using the ``image:`` syntax described "
"earlier. If no displayable is explicitly given, it will be computed from the "
"name of the layeredimage, the group (if any), the group's or the attribute's "
"variant (if any), and the attribute. See the :ref:`pattern <layeredimage-"
"pattern>` section for more details."
msgstr ""
"Displayable を指定でき、前述の ``image:`` 構文も使えます。Displayable が明示"
"的に指定されなければ、レイヤー画像名と(あれば)グループ、(あれば)グループまた"
"は属性の variant,, 属性の組み合わせから算出されます。詳細は :ref:`pattern "
"<layeredimage-pattern>` を参照ください。"

#: ../../source/layeredimage.rst:226
msgid "The attribute statement takes the following properties:"
msgstr "attribute ステートメントは次のプロパティーを受け取ります :"

#: ../../source/layeredimage.rst:234
msgid ""
"If present, these are used to construct a transform that is applied to the "
"layer."
msgstr ""
"与えられれば、レイヤーに適用される transform を構築するのに使用されます。"

#: ../../source/layeredimage.rst:238
msgid ""
"A transform or list of transforms that are applied to the layer. It can also "
"be used in the form of ``at transform:`` followed by an ATL block, to define "
"an ATL transform which will be applied to the layer."
msgstr ""
"レイヤーに適用される transform または transform のリスト。 ``at transform:`` "
"の後に ATL ブロックが続く形式で使用して、レイヤーに適用される ATL transform "
"を定義もできます。"

#: ../../source/layeredimage.rst:245 ../../source/layeredimage.rst:312
#: ../../source/inc/li_ff:22
msgid "`variant`"
msgstr "`variant`"

#: ../../source/layeredimage.rst:243
msgid ""
"A word that is prepended to the attribute name (with an underscore) when "
"looking for a displayable for that attribute. This property is only valid "
"for attributes with no given displayable, and which are not already in a "
"group with a variant."
msgstr ""

#: ../../source/layeredimage.rst:247
#, fuzzy
msgid ""
"The `when` clause's test is based upon the list of attributes of the "
"resulting image, as explained :ref:`here <concept-image>`, but it **does not "
"change** that list. ::"
msgstr ""
"`if_*` 節の評価は :ref:`こちら <concept-image>` で説明されたように、最終的な"
"画像の属性リストに基づきますが、そのリストは **変更しません** ::"

#: ../../source/layeredimage.rst:256
#, fuzzy
msgid ""
"In this example, the ``b`` and ``c`` attributes are *always* part of the "
"attributes list (because of their ``default`` clause). When calling ``show "
"eileen a``, the ``a`` attribute will be displayed as requested, and the "
"``b`` attribute will not, due to its ``when`` property. But even if not "
"displayed, the ``b`` attribute will still be part of the attributes list, "
"which means the ``c`` attribute will still not display."
msgstr ""
"この例では ``b`` と ``c`` 属性が ( それらの ``default`` 節のために ) *常に* "
"属性リストにあります。 ``show eileen a`` を呼び出すと、 ``a`` 属性が要求どお"
"り表示され、 ``b`` 属性はその ``if_not`` プロパティーにより表示されまん。しか"
"し、表示されなくとも ``b`` 属性は属性リストにはまだ残っています。つまり "
"``c`` 属性は表示されません。"

#: ../../source/layeredimage.rst:264
msgid "Group"
msgstr "Group"

#: ../../source/layeredimage.rst:266
#, fuzzy
msgid ""
"The ``group`` statement groups attributes together, making them mutually "
"exclusive. When attributes `a` and `b` are in the same group, it is an error "
"to include both of the attributes at the same time, with ``show eileen a b`` "
"for example, except when the group is ``multiple``. In the same example, "
"calling attribute `a` will hide attribute `b`, and vice versa. However, note "
"that it's fine for several ``attribute`` clauses to be passed the same name, "
"*even within the same group*. In that case, they will be considered as one "
"attribute containing several sprites - more about that at the end of this "
"section."
msgstr ""
"``group`` ステートメントは属性をグループ化し、相互に排他的にします。グループ"
"が ``multiple`` でない限り、属性 `a` と `b` が同じグループであるときに "
"``show eileen a b`` のように同時に両方の属性を含めるとエラーになります。同様"
"に、属性 `a` を呼び出すと属性 `b` が非表示になり逆もしかりです。ただし、 *同"
"じグループ内であっても* 複数の ``attribute`` 節に同じ名前が渡されてもよいので"
"注意してください。その場合、それらは複数のスプライトを含む1つの属性として扱わ"
"れます - 詳しくはこの章の最後で説明します。"

#: ../../source/layeredimage.rst:275
#, fuzzy
msgid ""
"The ``group`` statement takes a name. The name isn't used for very much, "
"except to generate the default names of attributes inside the group."
msgstr ""
"``group`` ステートメントは名前を受け取ります。その名前はあまり使用されず、グ"
"ループ内の属性のデフォルト名を生成するのに使われるのみです。しかし、 "
"``multiple`` group では名前はまったく使用されず影響もありません。"

#: ../../source/layeredimage.rst:278
#, fuzzy
msgid ""
"The group name ``multiple`` is reserved, it has the specific behavior of "
"making that group ``multiple``. In that case, no incompatibility is applied "
"to the attributes declared inside the block. This is useful to have a group "
"auto-define multiple attributes that are not exclusive, or to apply the same "
"properties to a set of attributes at once. This conflicts with the "
"``default`` keyword being given to one of the attributes. Note that "
"``multiple`` groups are very different from other, normal groups, and that "
"most of what's true about groups doesn't apply to them. Notably, they are "
"considered as not having a name at all."
msgstr ""
"``multiple`` キーワードも続けられます。与えられれば、ブロック内で宣言された属"
"性に非排他性が適用されます。これは排他的ではない複数の属性を自動定義するグ"
"ループや同じプロパティーを一度に属性のセットに適用するのに便利です。これは属"
"性の1つに ``default`` キーワードが与えられていると衝突します。 ``multiple`` "
"group は他とかなり異なることに注意してください。通常のグループに当てはまるこ"
"とはほとんど当てはまりません。"

#: ../../source/layeredimage.rst:287
#, fuzzy
msgid ""
"The name may be followed by the ``auto`` keyword. If it's present, after any "
"attributes in the group have been declared, Ren'Py will scan its list of "
"images for those that match the group's pattern (see :ref:`below "
"<layeredimage-pattern>`), with the specificity that in that case, the "
"``format_function`` passed to the layeredimage is ignored. Any images that "
"are found, except those corresponding to explicitly declared attributes, are "
"then added to the group as if declared using the ``attribute`` statement "
"inside the group's block. See the :ref:`layeredimage-examples` section for a "
"practical demo."
msgstr ""
"名前の後に ``auto`` キーワードを続けられます。これがあるとそのグループのすべ"
"ての属性が宣言された後、 Ren'Py は画像のリストをスキャンしてグループパターン"
"( :ref:`下記 <layeredimage-pattern>` 参照)にマッチするものを探しますが、この"
"とき layerdimage に渡された ``format_function`` は無視され、 `multiple` キー"
"ワードを指定されたグループ名も通常のグループ名のようにパターンに含まれます。"
"見つかった画像は明示的に宣言された属性に対応する物を除いて、すべての画像がそ"
"のグループのブロック内で ``attribute`` ステートメントで宣言されたかのようにグ"
"ループに追加されます。実践的なデモとして :ref:`layeredimage-examples` を参照"
"してください。"

#: ../../source/layeredimage.rst:297
#, fuzzy
msgid ""
"After this optional keyword, properties can then be declared on the first "
"line of the group, and it can take a block containing properties and "
"attributes."
msgstr ""
"これらの任意のキーワードに続いて、プロパティーはグループの最初の行で宣言でき"
"ます。グループはプロパティーや属性を含むブロックも持てます。"

#: ../../source/layeredimage.rst:300
#, fuzzy
msgid ""
"The group statement takes the properties ``attribute`` does - such as "
"``when``, ``at`` and so on. Properties supplied to the group are passed to "
"the attributes inside the group, unless overridden by the same property of "
"the attribute itself. Two properties are more specific to groups:"
msgstr ""
"group ステートメントは ``if_any`` や ``at`` などのように、 ``attribute`` プロ"
"パティーを受け取ります。グループに提供されたプロパティーは、属性自身の同じプ"
"ロパティーに上書きされない限りそのグループ内の属性に渡されます。加えてグルー"
"プに限定の 2 つのプロパティーがあります。"

#: ../../source/layeredimage.rst:306
msgid ""
"This is similar to the property ``attribute`` takes, except that it cannot "
"be passed to both the group _and_ to attributes within it. If given, this "
"should be a word. If present, it is used as the variant for automatically "
"generating image names for attributes with no explicitly passed displayables "
"(see the :ref:`pattern <layeredimage-pattern>` section for more details), "
"and it is used in the pattern used to search for images when automatically "
"defining attributes in ``auto`` groups (see above)."
msgstr ""

#: ../../source/layeredimage.rst:318
msgid "`prefix`"
msgstr "`prefix`"

#: ../../source/layeredimage.rst:315
#, fuzzy
msgid ""
"If given, this is a prefix that is concatenated using an underscore with the "
"manually or automatically defined attribute names. So if prefix is "
"``leftarm``, and ``attribute hip`` is encountered, ``show eileen "
"leftarm_hip`` will display it."
msgstr ""
"指定されるなら、手動または自動で定義された属性名とアンダースコアで連結される"
"接頭辞です。つまり prefix が \"leftarm\" で、属性名が \"hip\" なら、 \"show "
"eileen leftarm_hip\" でそれが表示されます。"

#: ../../source/layeredimage.rst:320
msgid ""
"An attribute may also be part of several groups, in which case the attribute "
"is incompatible with every other attribute in every group it's part of. This "
"can be useful for example for a `dress` attribute, to make it hide both any "
"top and any pants that may be showing when it gets displayed::"
msgstr ""
"ある属性が複数のグループに属すこともでき、その場合、その属性は属するグループ"
"内の他のすべての属性と排他的です。これは、例えば `dress` 属性の場合、表示され"
"たときにトップとパンツの両方を非表示するのに便利です ::"

#: ../../source/layeredimage.rst:334
msgid ""
"When several ``group`` blocks with the same name are defined in the same "
"layeredimage, they are considered to be different parts of a single group. "
"For example::"
msgstr ""
"同じレイヤー画像で同じ名前の ``group`` ブロックが定義されると、1つのグループ"
"の異なるパーツとして考慮されます。例 ::"

#: ../../source/layeredimage.rst:350
msgid ""
"In this example, ``eileen_sitting_arms_behind_mixed.png`` will contain her "
"left arm behind the table, and ``eileen_sitting_arms_infront_mixed.png`` "
"will contain her right arm on the table. When calling ``show eileen sitting "
"mixed``, the two images will be shown at the same time, respectively behind "
"and in front of the table. In this example, the `on_hips` attribute is "
"incompatible with the `on_table` attribute, because even though they are not "
"declared in the same block, they are both in the same group."
msgstr ""
"この例では、 ``eileen_sitting_arms_behind_mixed.png`` にはテーブルの後ろの左"
"手があり、 ``eileen_sitting_arms_infront_mixed.png`` にはテーブルの上の右手が"
"あります。 ``show eileen sitting mixed`` を呼び出すと、その二つの画像がそれぞ"
"れテーブルの後ろと前に同時に表示されます。同じブロックで宣言されていなくて"
"も、両方が同じグループなのでこの例では、 `on_hips` 属性は `on_table` 属性に対"
"して排他的です。"

#: ../../source/layeredimage.rst:361
msgid "When"
msgstr "When"

#: ../../source/layeredimage.rst:363
msgid ""
"A when expression expresses a boolean condition depending on the set of "
"attributes currently active on the layeredimage."
msgstr ""

#: ../../source/layeredimage.rst:366
msgid ""
"It consists of one or more attribute names separated by the \"and\" and \"or"
"\" keywords, and possibly negated with \"not\". You can also use parentheses "
"to express priority."
msgstr ""

#: ../../source/layeredimage.rst:370
msgid "Example::"
msgstr "例"

#: ../../source/layeredimage.rst:390
msgid "Deprecated Properties"
msgstr "非推奨のプロパティー"

#: ../../source/layeredimage.rst:392
msgid ""
"The following properties of the ``always``, ``if`` and ``attribute`` "
"statements are deprecated, but may be present in games written before the "
"``when`` clause was added. These still work, but ``when`` is preferred."
msgstr ""

#: ../../source/layeredimage.rst:399
msgid "`if_all`"
msgstr "`if_all`"

#: ../../source/layeredimage.rst:397
msgid ""
"A string or list of strings giving the names of attributes. If this is "
"given, this layer is only displayed if all of the named attributes are "
"present."
msgstr ""
"属性の名前の文字列または文字列リストです。これがあれば、このレイヤーはそのす"
"べての属性名が与えられなければ表示されません。"

#: ../../source/layeredimage.rst:404
msgid "`if_any`"
msgstr "`if_any`"

#: ../../source/layeredimage.rst:402
msgid ""
"A string or list of strings giving the names of attributes. If this is "
"given, this layer is only displayed if any of the named attributes are "
"present."
msgstr ""
"属性の名前の文字列または文字列リストです。これがあれば、このレイヤーはその属"
"性名のどれかが与えられなければ表示されません。"

#: ../../source/layeredimage.rst:409
msgid "`if_not`"
msgstr "`if_not`"

#: ../../source/layeredimage.rst:407
msgid ""
"A string or list of strings giving the names of attributes. If this is "
"given, this layer is only displayed if none of the named attributes are "
"present."
msgstr ""
"属性の名の文字列または文字列リストです。これがあれば、このレイヤーはその属性"
"名がすべて与えられなければ表示されます。"

#: ../../source/layeredimage.rst:411
msgid "To convert to the ``when`` syntax, you can replace::"
msgstr ""

#: ../../source/layeredimage.rst:417
msgid "with the more concise::"
msgstr ""

#: ../../source/layeredimage.rst:425
msgid "Pattern and format function"
msgstr "パターンとフォーマット関数"

#: ../../source/layeredimage.rst:427
msgid ""
"The pattern, used to find images for attributes when they are not explicitly "
"given one, consists of:"
msgstr ""
"属性に明示的に画像が与えられていないときに属性に対する画像を探すのに使用され"
"るパターンです。次で構成されます。 :"

#: ../../source/layeredimage.rst:430
msgid "The name of the layeredimage, with spaces replaced with underscores."
msgstr "スペースがアンダースコアで置換されたレイヤー画像名"

#: ../../source/layeredimage.rst:431
#, fuzzy
msgid "The name of the group, if we are in a non-\\ ``multiple`` group."
msgstr "グループがありかつ ``multiple`` でなければグループ名"

#: ../../source/layeredimage.rst:432
msgid "The name of the variant, if there is one."
msgstr "あれば variant の名前"

#: ../../source/layeredimage.rst:433
msgid "The name of the attribute."
msgstr "属性の名前"

#: ../../source/layeredimage.rst:435
msgid ""
"all combined with underscores. For example, if we have a layered image with "
"the name \"augustina work\", and the group \"eyes\", this will match images "
"that match the pattern augustina_work_eyes\\_\\ `attribute`. With a "
"`variant` of `blue`, it would match the pattern augustina_work_eyes_blue\\_"
"\\ `attribute`. In the following example::"
msgstr ""
"すべてはアンダースコアで結合されます。例えば、レイヤー画像 \"augustina work"
"\" とグループ \"eyes\" があれば、これはパターン augustina_work_eyes\\_\\ "
"`attribute` にマッチする画像にマッチします。 `variant` が `bule` なら、パター"
"ン augustina_work_eyes_blue\\_\\ `attribute` にマッチします。 ::"

#: ../../source/layeredimage.rst:445
#, fuzzy
msgid ""
"The attribute is linked to the image ``\"augustina_work_eyes_blue_closed"
"\"``. That can resolve to an image file named :file:"
"`augustina_work_eyes_blue_closed.png`, but it can also be defined explicitly "
"using the :ref:`image-statement` for example."
msgstr ""
"この例では、属性は画像 ``\"augustina_work_eyes_blue_closed\"`` にリンクされま"
"す。それにより :file:`augustina_work_eyes_blue_closed.png` の名前を持つ画像"
"ファイルに名前解決されますが、例えば :ref:`image-statement` を使用して明示的"
"にも定義できます。"

#: ../../source/layeredimage.rst:449
msgid ""
"All of the pattern behavior can be changed using a `format_function`: :func:"
"`layeredimage.format_function` is the function used under the hood to "
"implement the behavior described above. You can see what arguments it takes, "
"in case you want to supply your own `format_function` to replace it."
msgstr ""
"フォーマット関数を使用してパターンの動作を変更できます。 :func:`layeredimage."
"format_function` 上述の動作を実装するために内部で使用されている関数です。自身"
"のフォーマット関数で置き換えたいなら、これが何の引数をとるかを参照しましょ"
"う。"

#: ../../source/inc/li_ff:5
msgid ""
"This is called to format the information about an attribute or condition "
"into a displayable. This can be replaced by a creator, but the new function "
"should ignore unknown kwargs."
msgstr ""
"これを呼び出して属性や条件を displayable の情報にフォーマットします。制作者に"
"よって置き換えられますが、新しい関数は未知のキーワード引数を無視するべきで"
"す。"

#: ../../source/inc/li_ff:11
msgid "`what`"
msgstr "`what`"

#: ../../source/inc/li_ff:10
msgid ""
"A string giving a description of the thing being formatted, which is used to "
"create better error messages."
msgstr ""
"フォーマットされるものを記述する文字列で、よりよいエラーメッセージを作成する"
"ために使用されます。"

#: ../../source/inc/li_ff:14 ../../source/inc/li_proxy:9
msgid "`name`"
msgstr "`name`"

#: ../../source/inc/li_ff:14
msgid "The name of the layeredimage."
msgstr "レイヤー画像の文字列です。"

#: ../../source/inc/li_ff:18
msgid "`group`"
msgstr "`group`"

#: ../../source/inc/li_ff:17
msgid ""
"The group of an attribute, None if not supplied or if it's part of a "
"condition."
msgstr "属性のグループで、 提供されないか条件内での使用なら None になります。"

#: ../../source/inc/li_ff:21
msgid "The variant argument to the group, or None if it is not supplied."
msgstr "グループへの variant 引数で、提供されなければ None です。"

#: ../../source/inc/li_ff:25
msgid "`attribute`"
msgstr "`attribute`"

#: ../../source/inc/li_ff:25
msgid "The attribute itself."
msgstr "属性です。"

#: ../../source/inc/li_ff:28
msgid "`image`"
msgstr "`image`"

#: ../../source/inc/li_ff:28
msgid "Either a displayable or string."
msgstr "displayable または文字列です。"

#: ../../source/inc/li_ff:31
msgid "The image_format argument of the LayeredImage."
msgstr "LayerdImage の image_format 引数です。"

#: ../../source/inc/li_ff:33
msgid ""
"If `image` is None, then `name`, `group` (if not None), `variant` (if not "
"None), and `attribute` are combined with underscores to create `image`, "
"which will then be a string."
msgstr ""
"`image` が None なら、 `name` と (あれば) `group`,(あれば)  `variant`, "
"`attribute` がアンダースコアで結合され、 `image` の文字列になります。"

#: ../../source/inc/li_ff:37
msgid ""
"If `images` is a string, and `image_format` is not None, `image` is "
"formatted into the string to get the final displayable."
msgstr ""
"`images` が文字列で `image_format` が None でなければ、 `image` は最終的な "
"displayable を所得する文字列にフォーマットされます。"

#: ../../source/inc/li_ff:40
msgid ""
"So if `name` is \"eileen\", `group` is \"expression\", and `attribute` is "
"\"happy\", `image` would be set to \"eileen_expression_happy\". If "
"`image_format` is \"images/{image}.png\", the final image Ren'Py finds is "
"\"images/eileen_expression_happy.png\". But note that it would have found "
"the same image without the format argument."
msgstr ""
"つまり `name` が \"eileen\", `group` が \"expression\", `attribute` が "
"\"happy\" なら、 `image` は \"eileen_expression_happy\" に設定されます。 "
"`image_format` が \"images/{image}.png\" なら、Ren'Py が見つける最終的な画像"
"は \"images/eileen_expression_happy.png\" です。ただしフォーマット引数なしで"
"も同じ画像を見るので注意してください。"

#: ../../source/layeredimage.rst:456
msgid ""
"But note that the passed `format_function` does _not_ change how ``auto`` "
"groups will find their images : they will always use the exact pattern "
"described above."
msgstr ""
"ただし、渡された `format_function` は ``auto`` グループがそれらの画像を検索す"
"る方法は変更しないことに注意してください。それらは常に正確に上述のパターンを"
"使用します。"

#: ../../source/layeredimage.rst:460
msgid "Proxying Layered Images"
msgstr "Proxying Layered Images"

#: ../../source/layeredimage.rst:462
msgid ""
"Sometimes, it can be useful (and even necessary) to proxy a layered image, "
"to use the same layered image in multiple places. One reason for this would "
"be to have a transformed version of a given layeredimage, while another "
"would be to use it as a side image."
msgstr ""
"レイヤー画像を使い回して同じレイヤー画像を複数の場所で使用しなければならない"
"ときがあります。これは例えば、特定のレイヤー画像の transform を適用したバー"
"ジョンを作成して、サイドイメージとして使用するためです。"

#: ../../source/layeredimage.rst:467
msgid ""
"The :func:`LayeredImageProxy` object does this, taking one layered image and "
"duplicating it somewhere else. For example::"
msgstr ""
":func:`LayeredImageProxy` オブジェクトでこれを行います。レイヤー画像を1つ受け"
"取ってどこかに複製します。例 ::"

#: ../../source/layeredimage.rst:472
msgid ""
"creates a duplicate of the image that can be displayed independently. This "
"also takes a transform argument that makes it useful to position a side "
"image, like this::"
msgstr ""
"独立して表示出来る画像の複製を作成します。これはこのように transform を引数に"
"受け取るのでサイドイメージを配置するのに便利です。 ::"

#: ../../source/layeredimage.rst:478
msgid "See the difference::"
msgstr "次の例の違いに注目してください。 ::"

#: ../../source/layeredimage.rst:483
msgid ""
"``sepia_augustina_one`` will be a sepia version of the *original version* of "
"the \"augustina\" layeredimage, in other words what's shown when you don't "
"provide it any attribute. On the contrary, ``sepia_augustina_two`` will take "
"any attribute \"augustina\" does, and then apply the sepia effect onto the "
"result. If you can do this::"
msgstr ""
"``sepia_augustina_one`` はレイヤー画像 \"augustina\" の *デフォルトバージョン"
"* のセピアバージョンであり、言い換えると表示されるものは属性を何も与えないと"
"きのものです。対照的に、 ``sepia_augustina_two`` は \"augustina\" が受け取る"
"どの属性も受け取られ、それらにセピア調のエフェクトを適用します。元々次ができ"
"るとすると、 ::"

#: ../../source/layeredimage.rst:491
msgid "then::"
msgstr "このようになります。 ::"

#: ../../source/inc/li_proxy:5
msgid ""
"This is an image-like object that proxies attributes passed to it to another "
"layered image."
msgstr ""
"これは画像のようなオブジェクトです。渡される属性を他のレイヤー画像に中継しま"
"す。"

#: ../../source/inc/li_proxy:9
msgid "A string giving the name of the layeredimage to proxy to."
msgstr "中継するレイヤー画像の名前の文字列です。"

#: ../../source/inc/li_proxy:12
msgid "`transform`"
msgstr "`transform`"

#: ../../source/inc/li_proxy:12
msgid ""
"If given, a transform or list of transforms that are applied to the image "
"after it has been proxied."
msgstr ""
"与えるなら、中継先の画像に適用される transform または transform のリストで"
"す。"

#: ../../source/layeredimage.rst:504
msgid "Selecting attributes to display"
msgstr "表示する属性の選択"

#: ../../source/layeredimage.rst:506
msgid ""
"Several factors influence what gets displayed following a given :ref:`show-"
"statement`. To provide more clarity as to what happens in which order, this "
"section showcases the life of a set of attributes, from the show statement "
"to the on-screen display."
msgstr ""
"指定された :ref:`show-statement` に続いて何が表示されるかにはいくつかの要素が"
"影響します。どのような順番で何が起こるかをより明確にするために、このセクショ"
"ンでは show ステートメントから画面上の表示まで、一連の属性の一生を紹介しま"
"す。"

#: ../../source/layeredimage.rst:511
msgid ""
"The ``show`` statement provides the initial set of attributes, following the "
"image tag."
msgstr ""
"``show`` ステートメントは画像タグに続いて最初の属性のセットを提供します。"

#: ../../source/layeredimage.rst:513
msgid ""
"If a :var:`config.adjust_attributes` function exists to match the image tag, "
"it is called, and returns a potentially different set of attributes. If so, "
"it replaces the former set, which is forgotten."
msgstr ""
":var:`config.adjust_attributes` 関数があり、その画像タグに一致すれば呼び出さ"
"れて変更された可能性のある属性のセットを返します。そうであれば以前のセットは"
"置き換えられ、忘れられます。"

#: ../../source/layeredimage.rst:516
msgid ""
"If a :var:`config.default_attribute_callbacks` function exists and if its "
"trigger conditions are met, it is called and potentially adds attributes to "
"the set."
msgstr ""
":var:`config.default_attribute_callbacks` 関数があって、その実行条件が満たさ"
"れていれば、呼び出されてそのセットに属性が追加される可能性があります。"

#: ../../source/layeredimage.rst:520
msgid ""
"The previous stages are not specific to layeredimages, because it is only "
"after this stage that renpy determines which image or layeredimage will be "
"called to display. For that reason, the given set of attributes must lead to "
"one, and only one, defined image (or layeredimage, Live2D...), using the "
"behavior described in the :ref:`show statement section <show-statement>`."
msgstr ""
"前述の段階はレイヤー画像に限定されません。この後の段階で Ren'Py はどの画像ま"
"たはレイヤー画像が呼び出されて表示するか決定します。そのために、与えられた属"
"性のセットは、 :ref:`show statement section<show-statement>` で説明されている"
"動作で、1つの、そして唯一の定義された画像 ( または layeredimage, Live2D...) "
"につながる必要があります。"

#: ../../source/layeredimage.rst:526
#, fuzzy
msgid ""
"Then, the provided attributes are combined with the attributes defined in "
"the layeredimage, discarding some previously shown attributes and conserving "
"others. This is also the point when unrecognized attributes are detected and "
"related errors are raised. If no such error is raised, the new attributes, "
"along with those which were not discarded, will be recognized by renpy as "
"the set of attributes associated with that image tag. This computing takes "
"some of the incompatibility constraints into account, but not all. For "
"instance incompatibilities due to attributes being in the same non-multiple "
"group will trigger at this point in time, but the ``when`` clauses will not. "
"That's why an attribute called but negated by such a clause will be "
"considered active by renpy, and will for example become visible without "
"having to be called again, if at some point the condition of the if\\_x "
"clause is no longer fulfilled."
msgstr ""
"次に、提供された属性はレイヤー画像に定義された属性と結合され、先に表示されて"
"いた属性のいくつかは破棄され、他の属性は保存されます。認識されない属性はここ"
"で検出され、エラーが発生します。そのようなエラーが発生しなければ、新しい属性"
"と捨てられなかった属性が renpyによってその画像タグに関連する属性のセットとし"
"て認識されます。この計算では排他性の制約の一部を考慮に入れていますが、すべて"
"ではありません。例えば、属性が同じ非 multiple グループにあることによる排他性"
"はこの時点で発生しますが、if_any/if_all/if_not 節ではエラーは発生しません。そ"
"のため、このような節で否定された属性も renpy ではアクティブとみなされ、例え"
"ば、 if\\_x 節の条件が満たされなくなった時点で再度呼び出されなくとも表示され"
"るようになるのです。"

#: ../../source/layeredimage.rst:539
msgid ""
"If an ``attribute_function`` has been provided to the layeredimage, it is "
"called with the set of remaining attributes. It returns a potentially "
"different set of attributes."
msgstr ""
"``attribute_function`` がレイヤー画像に提供されている場合、残りの属性のセット"
"で呼び出されます。これは潜在的に異なる可能性のある属性のセットを返します。"

#: ../../source/layeredimage.rst:542
msgid ""
"This set is once again confronted with the incompatibility constraints of "
"the layeredimage, this time in full. That is the final stage, and remaining "
"attributes are called into display."
msgstr ""
"このセットは、もう一度レイヤー画像の非排他性の制約に直面します。これが最終段"
"階であり、残っている属性が表示されます。"

#: ../../source/layeredimage.rst:547
msgid "Advice"
msgstr "アドバイス"

#: ../../source/layeredimage.rst:549
msgid "**Use underscores in image filenames.**"
msgstr "**画像ファイル名ではアンダースコアを使用してください**"

#: ../../source/layeredimage.rst:551
msgid ""
"By default, Ren'Py's layered images use underscores to separate sections of "
"image names. It might be tempting to use images with spaces between "
"sections, but that could lead to problems later on."
msgstr ""
"デフォルトでは、 Ren'Py のレイヤー画像はアンダースコアで画像名をパーツに分割"
"します。パーツ間にスペースがある画像の使用は魅力的かもしれませんが、後述の問"
"題に発展しかねません。"

#: ../../source/layeredimage.rst:555
msgid ""
"Ren'Py has a rule that if you show an image with the exact name as one "
"that's being shown, it's shown instead. This can bypass the layered image "
"you defined and show the sprite directly on its own, which can lead to weird "
"problems like a pair of eyes floating in space."
msgstr ""
"Ren'Py には既に表示されているものと正確に同じ名前の画像を表示するときは置き換"
"えて表示するルールがあります。これにより定義したレイヤー画像ではなく、直接ス"
"プライトを表示する可能性があり、これはなにもない空間に目が浮かぶような妙な問"
"題に繋がる可能性があります。"

#: ../../source/layeredimage.rst:560
msgid ""
"By having each sprite have a different tag from the main image, this is no "
"longer a problem."
msgstr ""
"各レイヤーがメインの画像と異なるタグを持てばこれは問題ではなくなります。"

#: ../../source/layeredimage.rst:564
msgid "**Cropping layers isn't necessary.**"
msgstr "**レイヤーの切り取りは不要です**"

#: ../../source/layeredimage.rst:566
msgid ""
"Ren'Py optimizes images by cropping them to the bounding box of the non-"
"transparent pixels before loading them into RAM. As a result, assuming the "
"images are being predicted properly, it generally won't improve performance "
"or image size much to crop the images yourself."
msgstr ""
"Ren'Py は画像を RAM に読み込む前に、不透明なピクセルの矩形領域に切り取って画"
"像を最適化します。つまり画像が適切に予測されれば、自分で画像を切り取ってもパ"
"フォーマンスや画像サイズは一般的にあまり改善しません。"

#: ../../source/layeredimage.rst:572
msgid "**Layered images shouldn't use data that changes at runtime.**"
msgstr "**レイヤー画像には実行時に変化するデータを使用するべきではありません**"

#: ../../source/layeredimage.rst:574
#, fuzzy
msgid ""
"Note that with the exception of the conditions in the ``if`` statement, all "
"expressions written in a ``layeredimage`` block are evaluated at init time, "
"when the layered image is first defined. This is not the case for ATL "
"transforms for example, or for anything occurring in :var:`config."
"adjust_attributes`, :var:`config.default_attribute_callbacks` or "
"``attribute_function``, but it is the case for ``format_function`` which is "
"also only called at layeredimage definition."
msgstr ""
"``if`` ステートメントの条件を除いて、 ``layeredimage`` に記述されたすべての式"
"はそのレイヤー画像が最初に定義される初期化時に評価されることに注意してくださ"
"い。これは例えば ATL transform や :var:`config.adjust_attributes`, :var:"
"`config.default_attributes`, ``attribute_function`` の場合はその限りではな"
"く、レイヤー画像定義時にのみ呼び出される ``format_function`` には当てはまりま"
"す。"

#: ../../source/layeredimage.rst:582
msgid "**Choosing what syntax to use**"
msgstr "**使用する構文を選んでください**"

#: ../../source/layeredimage.rst:584
msgid ""
"If you want a sprite to be always visible, use either the ``always`` clause "
"or the ``attribute x default`` syntax. ``always`` will require you to "
"provide the displayable explicitly (automatic attribution using the :ref:"
"`pattern <layeredimage-pattern>` will not be available), but ``attribute`` "
"will spend the \"x\" attribute name which will always be active for that "
"layeredimage."
msgstr ""
"あるスプライトが常に見えるようにしたければ ``always`` 節や ``attribute x "
"default`` 構文を使用してください。 ``always`` は明示的な Displayable の提供を"
"要求します( :ref:`pattern <layeredimage-pattern>` を使用した自動的な属性は利"
"用不能です)。一方 ``attribute`` は \"x\" を属性名としてそのレイヤー画像で常に"
"アクティブにします。"

#: ../../source/layeredimage.rst:591
msgid ""
"If you want it to appear depending on the attributes being passed to the "
"layeredimage at the moment of the ``show`` statement, for example ``show "
"eileen happy`` instead of ``show eileen jeans``, use the ``attribute`` "
"statement, in or out of a ``group`` block (or implicitly defined in an "
"``auto`` group)."
msgstr ""
"``show`` ステートメントを使用してレイヤー画像に渡された属性にもとづいて表示し"
"たいなら、例えば ``show eileen jeans`` の代わりに ``show eileen happy`` な"
"ど、 ``attribute`` ステートメントを ``group`` ブロックの内と外で (もしくは明"
"示的に ``auto`` グループで定義して) 使用してください。"

#: ../../source/layeredimage.rst:597
msgid ""
"If you want it to appear depending on a python variable or condition, use "
"the ``if`` statement."
msgstr ""
"python 変数や条件にもとづいて表示したいなら、 ``if`` ステートメントを使用して"
"ください。"

#: ../../source/layeredimage.rst:600
msgid ""
"If you want it to depend on both (for example for ``show eileen ribbon`` to "
"show either a blue or red ribbon depending on a variable, but no ribbon "
"appearing unless you ask for it with the ``ribbon`` attribute), declare all "
"versions as attributes and use a dedicated :var:`config.adjust_attributes` "
"function."
msgstr ""
"両方に基づかせたい ( 例えば ``show eileen ribbon`` が青と赤どちらのリボンを表"
"示するかを変数に基づき、 ``ribbon`` 属性でリボンを表示するかを決めたい場合)"
"は、すべてのバージョンを属性として定義し、 :var:`config.adjust_attributes` 関"
"数を使用して調整してください。"

#: ../../source/layeredimage.rst:609
msgid "Examples"
msgstr "例"

#: ../../source/layeredimage.rst:611
msgid "**Pattern and auto groups**"
msgstr "**パターンと自動グループ**"

#: ../../source/layeredimage.rst:613
msgid ""
"From the following files in the images/ directory (or one of its subfolders) "
"and written code:"
msgstr ""
"images/ ディレクトリ ( またはそのサブディレクトリの1つ)に次のファイルがあり、"
"次のコードを記述します :"

#: ../../source/layeredimage.rst:638
msgid ""
"The ``francis`` layeredimage will declare the (defaulted) ``base`` "
"attribute, and associate it the \"francis_base\" (auto-defined) image using "
"the :ref:`pattern <layeredimage-pattern>` : the layeredimage name (\"francis"
"\"), the group name (none here), the variant name (none here) and the "
"attribute name (\"base\"), separated with underscores."
msgstr ""
"``francis`` レイヤー画像は ``base`` 属性をデフォルトとして宣言し、 :ref:`パ"
"ターン <layeredimage-pattern>` を使用して(自動定義により)それを "
"\"francis_base\" 画像に紐付けます。: レイヤー画像名(\"francis\")、グループ名"
"(ここではなし)、 variant 名(ここではなし)、属性名 (\"base\") がアンダースコア"
"で分割されます。"

#: ../../source/layeredimage.rst:644
msgid ""
"Then, in the ``face`` group, the explicit ``neutral`` attribute gets "
"associated the \"francis_face_neutral\" image, following the same pattern "
"but using \"face\" as the group name and \"neutral\" as the attribute name."
msgstr ""
"次に ``face`` グループで明示的な ``neutral`` 属性が \"francis_face_neutral\" "
"画像に紐付けられます。上記と同じパターンですが、ここではグループ名として "
"\"face\" を属性名として \"neutral\" を使用します。"

#: ../../source/layeredimage.rst:648
msgid ""
"After all explicit attributes receive their images, ``face`` being an "
"``auto`` group, existing images (auto-defined or not) are scanned for a "
"match with the pattern. Here, three are found : \"francis_face_angry\", "
"\"francis_face_happy\" and \"francis_face_very_happy\". They are associated "
"with the ``angry``, ``happy`` and ``very_happy`` attributes respectively, "
"using the same pattern as before. No ``annoyed`` attribute is defined "
"however, since the \"francis_face annoyed\" image contains a space where the "
"pattern expected an underscore."
msgstr ""
"すべての明示的な属性が画像を受け取ると、 ``face`` は ``auto`` であるので、既"
"存の画像（自動定義されているかどうかは別として）がパターンにマッチするかどう"
"かスキャンされます。ここでは、\"francis_face_angry\", \"francis_face_happy"
"\", \"francis_face_very_happy\" の3つが検出されました。これらはそれぞれ、先ほ"
"どと同じパターンを使用して ``angry``, ``happy``, ``very_happy`` 属性と関連付"
"けられます。しかし、\"francis_face annoyed\" 画像にはアンダースコアが必要なと"
"ころにスペースが含まれているため、``annoyed`` 属性は定義されません。"

#: ../../source/layeredimage.rst:656
msgid ""
"Finally, the ``supersad`` attribute is declared, but since a displayable is "
"explicitly provided, the pattern does not look for a matching image."
msgstr ""
"最後に、 ``supersad`` 属性が宣言されますが、 displayable が明示的に指定されて"
"いるため、パターンではマッチする画像を探しません。"

#: ../../source/layeredimage.rst:659
msgid ""
"The \"francis_supersad\" and \"francis_face annoyed\" images get auto-"
"defined from the filename as part of Ren'Py's ordinary :ref:`protocol "
"<images-directory>`, but these sprites don't find a match with any attribute "
"or auto group, so they end up not being used in the ``francis`` layeredimage."
msgstr ""
"\"francis_supersad\" と \"francis_face annoyed\" 画像は Ren'Py の通常の :ref:"
"`プロトコル <images-directory>` の一環として、ファイル名から自動定義されます"
"が、これらのスプライトはどのような属性やグループにもマッチされないため "
"``francis`` レイヤー画像には結局使用されません。"

#: ../../source/layeredimage.rst:664
msgid ""
"As you can see, using the pattern to associate images to attributes and "
"using auto groups shrinks the code considerably. The same layeredimage would "
"have taken 13 lines if everything was declared explicitly (try it!), and "
"this syntax allows for geometric growth of the sprite set - adding any "
"number of new faces wouldn't require any change to the code, for example."
msgstr ""
"見ての通り、パターンの使用により画像を属性に対応させ、自動グループによりコー"
"ドを有意に省略できます。同じレイヤー画像をすべて明示的に宣言しようとすると、"
"13 行必要になり、この構文により、スプライトの組み合わせの幾何学的な増加が可能"
"になります(新しい顔をいくつか追加しても、コードを変更する必要がなくなりま"
"す)。"

#: ../../source/layeredimage.rst:671
msgid "**Dynamism in attributes**"
msgstr "**動的な属性**"

#: ../../source/layeredimage.rst:673
msgid ""
"Here is an example for defining attributes depending on variables (as "
"mentioned in the Advice section)::"
msgstr "こちらは(本章で述べたように)変数にもとづく属性を定義する例です。"

#: ../../source/layeredimage.rst:696
msgid "**Including groups in when**"
msgstr ""

#: ../../source/layeredimage.rst:698
msgid ""
"The ``when`` property does not allow a group name to be specified, so that a "
"given layer be shown only when any or none of the attributes in a given "
"group are shown. However, there is still a way to do that using the various "
"other parts of the layeredimage syntax."
msgstr ""

#: ../../source/layeredimage.rst:700
msgid ""
"Supposing that the group has no default attribute, you can add a default "
"``null`` attribute, with a name of your choice. That way, if no attribute "
"from the group is shown, that attribute is activated (although nothing gets "
"displayed), and it gets reactivated if an attribute of the group gets hidden."
msgstr ""

#: ../../source/layeredimage.rst:713
msgid ""
"Here, the hair_patch attribute will only show more of Eliza's hair over her "
"top layer (on her shoulders for example) if there is no hat to hide it."
msgstr ""

#, fuzzy
#~ msgid "`if_attr`"
#~ msgstr "`if_all`"

#~ msgid ""
#~ "A transform or list of transforms that are applied to the layered image."
#~ msgstr "レイヤー画像へ適用される transform または transform のリストです。"

#~ msgid ""
#~ "A transform or list of transforms that are applied to the provided "
#~ "displayable."
#~ msgstr "displayable に適用される transform または transform のリストです。"

#~ msgid ""
#~ "A string or list of strings giving the names of attributes. If this is "
#~ "given, this condition is only considered if all of the named attributes "
#~ "are present."
#~ msgstr ""
#~ "属性名の文字列または文字列のリストです。これがあれば、この条件はそのすべて"
#~ "の属性名が与えられなければ考慮されません。"

#~ msgid ""
#~ "A string or list of strings giving the names of attributes. If this is "
#~ "given, this condition is only considered if any of the named attributes "
#~ "are present."
#~ msgstr ""
#~ "属性名の文字列または文字列のリストです。これがあれば、この条件はその属性名"
#~ "のどれかが与えられなければ考慮されません。"

#~ msgid ""
#~ "A string or list of strings giving the names of attributes. If this is "
#~ "given, this condition is only considered if none of the named attributes "
#~ "are present."
#~ msgstr ""
#~ "属性名の文字列または文字列のリストです。これがあれば、この条件はその属性名"
#~ "がすべて与えられなければ考慮されます。"

#~ msgid ""
#~ "A transform or list of transforms that are applied to the displayable."
#~ msgstr "Displayable に適用される transform または transform のリストです。"

#~ msgid ""
#~ "A string or list of strings giving the names of attributes. If this is "
#~ "present, this layer is only displayed if all of the named attributes are "
#~ "present."
#~ msgstr ""
#~ "属性名の文字列または文字列リストです。これがあれば、このレイヤーはそのすべ"
#~ "ての属性名が与えられなければ表示されません。"

#~ msgid ""
#~ "A string or list of strings giving the names of attributes. If this is "
#~ "present, this layer is only displayed if any of the named attributes are "
#~ "present."
#~ msgstr ""
#~ "属性名の文字列または文字列リストです。これがあれば、このレイヤーはその属性"
#~ "名のどれかが与えられなければ表示されません。"

#~ msgid ""
#~ "A string or list of strings giving the names of attributes. If this is "
#~ "present, this layer is only displayed if none of the named attributes are "
#~ "present."
#~ msgstr ""
#~ "属性名の文字列または文字列リストです。これがあれば、このレイヤーはその属性"
#~ "名がすべて与えられなければ表示されます。"

#~ msgid "A transform or list of transforms that are applied to the layer."
#~ msgstr "レイヤーに適用される transform または transform のリストです。"

#~ msgid ""
#~ "If given, this should be a string. If present, it adds an element that "
#~ "becomes part of automatically-generated image names, and of the pattern "
#~ "used to search for images when automatically defining attributes in "
#~ "``auto`` groups."
#~ msgstr ""
#~ "指定されるならこれは文字列であり、自動生成の画像名の一部と ``auto`` グルー"
#~ "プで属性を自動定義するときの画像の検索パターンの一部になります。"

#~ msgid ""
#~ "If you want a ``multiple`` group's name to be included in the pattern, "
#~ "you can use the following syntax::"
#~ msgstr ""
#~ "``multiple`` グループの名前をパターンに含めたければ、次の構文が使えま"
#~ "す。 ::"

#~ msgid ""
#~ "The layered image domain-specific language consists of only a few "
#~ "statements, one of which is also a script language statement to introduce "
#~ "the image, followed by statements to introduce the layers and groups of "
#~ "layers."
#~ msgstr ""
#~ "レイヤー画像用の言語はほんの少数のステートメントで構成され、その1つは画像"
#~ "を導入するステートメントで、続いてレイヤーやレイヤーのグループを導入するた"
#~ "めのステートメントが続きます。"

#~ msgid ""
#~ "To introduce the language, here's a layered image that uses the available "
#~ "features, with things that could be implied instead explicitly given. ::"
#~ msgstr ""
#~ "この言語の紹介のため、ここで利用可能な機能を使用したレイヤー画像を示しま"
#~ "す。 ::"

#~ msgid ""
#~ "That is a large amount of script, but it's very regular, and below we'll "
#~ "show how to simplify it."
#~ msgstr ""
#~ "長いスクリプトですが、かなり定型的なものです。以下でどのように簡略化してい"
#~ "るかを述べます。"

#~ msgid ""
#~ "First off, the ``layeredimage`` statement introduces a layered image with "
#~ "the name of the sprite. This statement is part of the Ren'Py script "
#~ "language, and runs at init time."
#~ msgstr ""
#~ "最初に ``layerdimage`` ステートメントでそのスプライトの名前とともにレイ"
#~ "ヤー画像を導入します。このステートメントは Ren'Py スクリプト言語の一部で初"
#~ "期化時に実行されます。"

#~ msgid ""
#~ "The block of a layered image can contain always, group, and if "
#~ "statements. A ``group`` statement can take attributes. The ``always`` and "
#~ "``if`` statements must be supplied displayables, while the attribute "
#~ "statement can optionally be supplied one. All statements can be supplied "
#~ "properties."
#~ msgstr ""
#~ "レイヤー画像のブロックには always と group, if ステートメントを含められま"
#~ "す。 ``group`` ステートメントは属性を受け取れます。 ``always`` と ``if`` "
#~ "ステートメントには displayable が提供されなければなりませんが、 "
#~ "``attribute`` ステートメントへの提供は任意です。すべてのステートメントには"
#~ "プロパティーが提供出来ます。"

#~ msgid ""
#~ "The ``always`` statement declares a layer that is always displayed, like "
#~ "the background of a sprite."
#~ msgstr ""
#~ "``always`` ステートメントはスプライトの背景のような常に表示されるレイヤー"
#~ "を宣言します。"

#~ msgid ""
#~ "The ``group`` statement introduces a group of attributes, where only one "
#~ "of the attributes can be displayed at a time. So this layered image can "
#~ "only have one outfit, and one post for each of the eyes, eyebrows, and "
#~ "mouth. Properties given to the group are passed on to the attributes, and "
#~ "a group can automatically declare attributes."
#~ msgstr ""
#~ "``group`` ステートメントは一度にその属性のうちの1つだけが表示される属性グ"
#~ "ループを導入します。これにより、このレイヤー画像は目、眉、口それぞれの位置"
#~ "で1つずつ、服で1つしか出力されません。グループへのプロパティーはその属性に"
#~ "渡され、グループでは自動的に属性を宣言できます。"

#~ msgid ""
#~ "The ``attribute`` statement introduces a layer that is displayed if an "
#~ "attribute is supplied to the image. For example, \"augustina_outfit_dress"
#~ "\" is only displayed if if the \"dress\" attribute is supplied. If given "
#~ "the ``default`` keyword, the attribute is displayed if no conflicting "
#~ "attributes are provided; in this example, \"augustina_eyes_open\" is "
#~ "displayed unless the unless the \"wink\" attribute is given."
#~ msgstr ""
#~ "``attribute`` ステートメントは画像にある属性が提供されると表示されるレイ"
#~ "ヤーを導入します。例では \"dress\" 属性が提供されるときのみ "
#~ "\"augustina_outfit_dress\" が表示されます。 ``default`` キーワードが属性に"
#~ "与えられると、矛盾する属性が与えられなければ、その属性が表示されます。この"
#~ "例では \"wink\" 属性がなければ \"augustina_eyes_open\" が表示されます。"

#~ msgid ""
#~ "Finally, the ``if`` statement adds a layer that selects between "
#~ "displayables using a Python statement. This is evaluated constantly, and "
#~ "the first condition that evaluates to true is the one that's displayed."
#~ msgstr ""
#~ "最後に、 ``if`` ステートメントは Python ステートメントを使用して  "
#~ "displayable を選択するレイヤーを追加します。これは毎回評価され、最初に "
#~ "True と評価される条件が表示されます。"

#~ msgid ""
#~ "Properties consist of a property name and a simple expression, and can be "
#~ "given to each layer. Some properties change the functioning of a "
#~ "statement. If one or more :ref:`transform properties <transform-"
#~ "properties>` are given, a :func:`Transform` is created that wraps the "
#~ "display. The at property can be given a transform or list of transforms "
#~ "that also wrap the displayable. For example, the pos property here "
#~ "creates a transform that moves the top-left corner of each mouth image."
#~ msgstr ""
#~ "プロパティーはプロパティー名と単純式で構成され、各レイヤーに提供されます。"
#~ "ステートメントの機能を変更するプロパティーもあります。ひとつ以上の :ref:"
#~ "`transform プロパティー <transform-properties>` があたえられると、 :func:"
#~ "`Transform` が作成されて displayable をラップします。 at プロパティーには "
#~ "displayable をラップする transform または transform リストも与えられます。"
#~ "例えば、ここで pos プロパティーは各口の画像の左上端を移動する transform を"
#~ "作成しています。"

#~ msgid ""
#~ "The resulting image is the size of the bounding box of all the layers, so "
#~ "it probably makes sense to have one layer the full size of the image, "
#~ "which no other layer goes outside of. The first layer is in the back of "
#~ "the image, while the last is in front – in this example, the glasses will "
#~ "be on top of the other layers. It's recommended to avoid properties that "
#~ "assume the size of the containing image, like :propref:`xcenter` and :"
#~ "propref:`xalign`, as these properties do not work well the when the image "
#~ "size is not known."
#~ msgstr ""
#~ "最終的な画像は全てのレイヤーの矩形領域の最大サイズとなるため、画像からはみ"
#~ "出すレイヤーがない十分な大きさのレイヤーが1つあるとよいでしょう。最初のレ"
#~ "イヤーは画像の後ろに、最後のは前になります。この例では、眼鏡が他のレイヤー"
#~ "の上となります。画像サイズが不明なとき正常に動作しないので :propref:"
#~ "`xcenter` や :propref:`xalign` のような含む画像のサイズを仮定するプロパ"
#~ "ティーは避けましょう。"

#~ msgid ""
#~ "Groups and attributes may appear more than once in a layered image, with "
#~ "all of the layers with an attribute being displayed."
#~ msgstr ""
#~ "group と attribute は表示される属性をもつ全てのレイヤーとともに "
#~ "layeredimage に一回以上表れるでしょう。"

#~ msgid ""
#~ "With the exception of the condition in an ``if`` statement, all Python "
#~ "expressions are evaluated at init time."
#~ msgstr ""
#~ "`if`` ステートメントの condition を除いて Python 式は初期化時にすべて評価"
#~ "されます。"

#~ msgid "Using an Layered Image"
#~ msgstr "レイヤー画像の使用"

#~ msgid ""
#~ "To use this (but not other) layered images, the evil variable must be "
#~ "given a value, for example with::"
#~ msgstr ""
#~ "この例でのレイヤー画像を使用するには evil 変数に値を与えなければなりませ"
#~ "ん。 例 ::"

#~ msgid ""
#~ "Then the layered image can be shown like any other image. Almost "
#~ "certainly, one of the outfits should be given – while Ren'Py doesn't "
#~ "enforce this, this image requires one::"
#~ msgstr ""
#~ "これでレイヤー画像は他の画像のように表示出来ます。ほぼ確実に outfit のどれ"
#~ "かは与えられるでしょうが、 Ren'Py はこれを強制しないので、この画像はどれか"
#~ "を必要とします。 ::"

#~ msgid ""
#~ "While a sprite is being shown, additional attributes will be added to "
#~ "those already showing provided they do not conflict. (This is the case in "
#~ "all of Ren'Py when an image being shown does not match one that's already "
#~ "defined, something that is never the case with a layered image.) So, ::"
#~ msgstr ""
#~ "スプライトが表示されている間、衝突しなければ追加の属性は既に表示されている"
#~ "スプライトに加えられます(これは表示されている画像が既に定義されている画像"
#~ "に一致しないときにRen'Pyのどこででも起こりますが、レイヤー画像では起こりま"
#~ "せん)。そのため、次のコードでは ::"

#~ msgid ""
#~ "Will activate the layers associated with the wink attribute. We could "
#~ "stop winking with::"
#~ msgstr ""
#~ "wink 属性と関連付けされたレイヤーをアクティベートします。開いた目はウィン"
#~ "クと衝突するので次のようにしてウィンクを止められます。 ::"

#~ msgid ""
#~ "As the open eyes conflict with the winking eyes. Or we could simply "
#~ "remove the wink attribute using::"
#~ msgstr "もしくは単に wink 属性を次のようにして除去できます。 ::"

#~ msgid ""
#~ "Which would display the layer with the open attribute, as it is the "
#~ "default."
#~ msgstr "これはデフォルトの open 属性で画像を表示します。"

#~ msgid "Automatic Attributes"
#~ msgstr "自動属性"

#~ msgid ""
#~ "There's a lot of repetition our first example, when it comes to the "
#~ "attribute names and the displayables that define the attribute. To save "
#~ "you from having to do a lot of redundant typing, Ren'Py can automatically "
#~ "determine a displayable name from the image name, group name, and "
#~ "attribute name. This is done by combining the names with underscores."
#~ msgstr ""
#~ "最初の例では属性を定義する属性名と displayable で多くの繰り返しがありま"
#~ "す。冗長なタイピングを避けるため、 Ren'Py では画像名、グループ名、属性名か"
#~ "ら自動的に displayable の名前を定義できます。これは名前とアンダースコアを"
#~ "組み合わせて行います。"

#~ msgid ""
#~ "When doing this, you can also take advantage of another feature of "
#~ "attributes – it's possible to add any properties to the first line and "
#~ "omit the block entirely."
#~ msgstr ""
#~ "これには属性のもう一つの機能、プロパティーを最初の行に追加してブロックを完"
#~ "全に省略できることを利用できます。"

#~ msgid "Here's our example of having done that::"
#~ msgstr "ここにこれを実行する例を示します。 ::"

#~ msgid ""
#~ "This example is equivalent to the first one (as we gave the same names "
#~ "for the displayables in the first example). For example, the dress "
#~ "attribute in the outfit group uses \"augustina_outfit_dress\" for the "
#~ "displayable, a displayable that references the image with  that name."
#~ msgstr ""
#~ "(displayable に最初の例と同じ名前を与えているため)この例は最初の例と同じこ"
#~ "とをしています。例えば、 outfit グループの dress 属性は displayable に "
#~ "\"augustina_outfit_dress\" を使用し、 displayable はその名前で画像を参照し"
#~ "ます。"

#~ msgid ""
#~ "It's possible to go even further than this, by automatically defining the "
#~ "attributes in a group. This is done by giving a group the `auto` keyword, "
#~ "which causes the group to search for defined images that would match the "
#~ "pattern, then define the attribute if it does not already exist."
#~ msgstr ""
#~ "自動的にグループの属性を定義して、さらに簡略化が可能です。これはグループ"
#~ "に、パターンにマッチする定義した画像を検索させ、衝突しなければその属性を定"
#~ "義する `auto` キーワードを与えて実行されます。"

#~ msgid ""
#~ "As with ``attribute``, properties can be placed on the first line of the "
#~ "group and the block omitted. The displayable and properties of the always "
#~ "statement can be put on the first line the same way."
#~ msgstr ""
#~ "``attribute`` のように、プロパティーをグループの最初の行に配置してブロック"
#~ "を省略できます。 always ステートメントの displayable と プロパティーも同様"
#~ "に最初の行に配置できます。"

#~ msgid "Here's an example of the final form::"
#~ msgstr "最後の形式の例です。 ::"

#~ msgid ""
#~ "This is about as simply as we can define that image, without changing "
#~ "what we define. The savings with auto-definition increases as we have "
#~ "more attributes per group. We could also save lines if we didn't need "
#~ "default attributes. In that case, all of the groups could be written on "
#~ "single lines."
#~ msgstr ""
#~ "これは画像を定義するのと同じぐらい簡単です。グループ毎により多くの属性があ"
#~ "れば、自動定義での節約はより増加します。デフォルト属性がいらなければ、更に"
#~ "行も節約できます。その場合、全てのグループが1つの行で記述されます。"

#~ msgid ""
#~ "There's no way to omit the displayables from the ``always`` or ``if`` "
#~ "statements, so this is as short as it gets – but with a few more images "
#~ "with proper names, it's possible to use this to define thousands or even "
#~ "millions of combinations of layers."
#~ msgstr ""
#~ "``always`` や ``if`` ステートメントでは、 displayable を省略できないため、"
#~ "(もう少し適切な名前の画像がありますが)これが一番簡略です。これによって数千"
#~ "数万のレイヤーの組み合わせさえ定義できます。"

#~ msgid ""
#~ "Note that with the exception of the conditions in the ``if`` statement, "
#~ "all expressions are evaluated at init time, when the layered image is "
#~ "first defined."
#~ msgstr ""
#~ "そのレイヤー画像が最初に定義される初期化時に ``if`` ステートメントの条件式"
#~ "以外のすべての式が評価されることに注意してください。"

#~ msgid ""
#~ "The ``layeredimage`` statement is a statement in the Ren'Py script "
#~ "language that introduces a layered image. It starts with an image name, "
#~ "and takes a block that can contain attribute, group, and if statements."
#~ msgstr ""
#~ "``layerdimage`` ステートメントはレイヤー画像を導入する Ren'Py スクリプト言"
#~ "語のステートメントです。これは画像名で始まり、 attribute, group, if ステー"
#~ "トメントなどを含むブロックを含みます。"

#~ msgid "Layeredimage takes the following properties:"
#~ msgstr "layerdimage は次のプロパティーを受け取ります。 :"

#~ msgid ""
#~ "If present, these are used to construct a :func:`Transform` that is "
#~ "applied to the displayable."
#~ msgstr ""
#~ "与えられると、 displayable に適用される :func:`Transform` を構築するのに使"
#~ "われます。"

#~ msgid ""
#~ "If the displayable is not explicitely given, it will be computed from the "
#~ "name of the layeredimage, the group (if any), the group's variant (if "
#~ "any), and the attribute, by replacing all spaces with underscores and "
#~ "using underscores to combine everything together. So if we have an image "
#~ "named \"augustina\", the group \"eyes\", no group variant, and the "
#~ "attribute \"closed\", the image \"augustina_eyes_closed\" will be used. "
#~ "(The layered image's format function is used to do this, defaulting to :"
#~ "func:`layeredimage.format_function`.)"
#~ msgstr ""
#~ "displayable が明示的に指定されなければ、そのレイヤー画像名や(あれば)グルー"
#~ "プ、(あれば)グループバリエーション、属性の名前から、すべてのスペースをアン"
#~ "ダースコアで置き換え、さらにアンダースコアで全てを結合して推測します。つま"
#~ "り画像名 \"augustina\" , グループ \"eyes\", 属性 \"closed\" があれば、画"
#~ "像 \"augustina_eyes_closed\" が使用されます( レイヤー画像のフォーマット関"
#~ "数がこれに使用され、デフォルトは :func:`layeredimage.format_function` で"
#~ "す)。"

#~ msgid ""
#~ "The ``group`` statement groups together alternative layers. When an "
#~ "attribute is inside a group, and unless the group is ``multiple``, it is "
#~ "an error to include any of the other attributes in that group. (But it's "
#~ "fine for several attributes to have same name, even within the same "
#~ "group.)"
#~ msgstr ""
#~ "``group`` ステートメントはレイヤーをグループ化します。ある属性がグループ内"
#~ "にあり、そのグループが ``multiple`` でないならば、そのグループの他の属性を"
#~ "含むのはエラーになります(同じグループ内であっても、いくつかの属性が同じ名"
#~ "前を持つことは良いです)。"

#~ msgid "There are two properties that are specific to groups."
#~ msgstr "グループに指定される 2 つのプロパティーがあります。"

#~ msgid "**Pattern.** The image pattern used consists of:"
#~ msgstr "**Pattern.** 使用される画像パターンは次で構成されます。 :"

#~ msgid "Poses"
#~ msgstr "Poses"

#~ msgid ""
#~ "It's possible to have a character that has sprites in multiple poses, "
#~ "where everything – or at least everything of interest – is different. For "
#~ "example, if a character has standing and sitting poses, all the image "
#~ "parts will be in different places."
#~ msgstr ""
#~ "全て、または少なくとも興味がある全てが異なる複数のポーズのスプライトがある"
#~ "キャラクターを持てます。例えばキャラクターに立ちポーズと座りポーズがあれ"
#~ "ば、全ての画像のパーツは異なる場所にあるでしょう。"

#~ msgid ""
#~ "In that case, it makes sense to define multiple layered images for the "
#~ "same image tag. The ``layeredimage`` statement makes this possible by "
#~ "allowing you to include attributes as part of the image name. So we can "
#~ "have::"
#~ msgstr ""
#~ "その場合、同じ画像タグの複数のレイヤー画像の定義が役立ちます。 "
#~ "``layerdimage`` ステートメントでは画像名の一部として属性を含められるので、"
#~ "これが可能になります。"

#~ msgid ""
#~ "This is especially useful when using a layered image to compose a side "
#~ "image, where the side images of different characters will have nothing to "
#~ "do with each other. ::"
#~ msgstr ""
#~ "これは特にレイヤー画像を使用してサイドイメージを構成するのに便利です。別々"
#~ "のキャラクターのサイドイメージは互いに影響しません。"

#~ msgid ""
#~ "**Layered images shouldn't use data that changes at runtime.** With the "
#~ "exception of the condition inside an if statement, all of the expressions "
#~ "in a layered images are run at init time. The layered image will not pick "
#~ "up changes in variables that occur after the game starts. (However, "
#~ "expressions in ATL transforms will be run each time the image is show, as "
#~ "with other ATL transforms.)"
#~ msgstr ""
#~ "**レイヤー画像では起動時に変化するデータを使用してはいけません** if ステー"
#~ "トメントの condition を除いて、レイヤー画像のすべての式は初期化時に実行さ"
#~ "れ、ゲーム開始後に起きた変数の変化を反映しません(ただし ATL transform の式"
#~ "は他の ATL transform と同様に画像の表示ごとに実行されます)。"

#~ msgid "Python"
#~ msgstr "Python"

#~ msgid ""
#~ "Of course, the ``layeredimage`` statements have a Python equivalents. The "
#~ "group statement does not – the group is supplied to ``attribute``, and "
#~ "the auto functionality can be implemented using :func:`renpy.list_images`."
#~ msgstr ""
#~ "もちろん ``layerdimage`` ステートメントには相当する Python がありますが、 "
#~ "group ステートメントは ``attribute`` に与えられるためありません。自動機能"
#~ "は :func:`renpy.list_image` を使用して実装できます。"

#~ msgid ""
#~ "This is used to represent a layer of an LayeredImage that is controlled "
#~ "by an attribute. A single attribute can control multiple layers, in which "
#~ "case all layers corresponding to that attribute will be displayed."
#~ msgstr ""
#~ "これを使用して属性に制御される LayerdImage のレイヤーを表します。1つの属性"
#~ "で複数のレイヤーを制御でき、この場合、その属性に対応する全てのレイヤーが表"
#~ "示されます。"

#~ msgid ""
#~ "A string giving the group the attribute is part of. This may be None, in "
#~ "which case a group with the same name as the attribute is created."
#~ msgstr ""
#~ "属性が加わるグループの文字列です。 None である場合、属性と同じ名前のグルー"
#~ "プが作成されます。"

#~ msgid "A string giving the name of the attribute."
#~ msgstr "属性の名前の文字列です。"

#~ msgid ""
#~ "If not None, this should be a displayable that is displayed when this "
#~ "attribute is shown."
#~ msgstr "これは None または、この属性が表示される displayable です。"

#~ msgid "`default`"
#~ msgstr "`default`"

#~ msgid ""
#~ "If True, and no other attribute for the group is selected, this attribute "
#~ "is."
#~ msgstr ""
#~ "True かつそのグループの他の属性が選択されていなければ、この属性となりま"
#~ "す。"

#~ msgid "The following keyword arguments are also known:"
#~ msgstr "次のキーワード引数もあります。 :"

#~ msgid "A transform or list of transforms that are applied to the image."
#~ msgstr "画像に適用される transform または transform のリストです。"

#~ msgid ""
#~ "An attribute or list of attributes. The displayable is only shown if all "
#~ "of these are showing."
#~ msgstr ""
#~ "属性または属性のリストです。 displayable はこれらの全てがあるときだけ表示"
#~ "されます。"

#~ msgid ""
#~ "An attribute or list of attributes. if not empty, the displayable is only "
#~ "shown if any of these are showing."
#~ msgstr ""
#~ "属性または属性のリストです。 displayable はこれらのどれかがあるときだけ表"
#~ "示されます。"

#~ msgid ""
#~ "An attribute or list of attributes. The displayable is only shown if none "
#~ "of these are showing."
#~ msgstr ""
#~ "属性または属性のリストです。 displayable はこれらの全てがないときだけ表示"
#~ "されます。"

#~ msgid ""
#~ "Other keyword arguments are interpreted as transform properties. If any "
#~ "are present, a transform is created that wraps the image. (For example, "
#~ "pos=(100, 200) can be used to offset the image by 100 pixels horizontally "
#~ "and 200 vertically.)"
#~ msgstr ""
#~ "他のキーワード引数は transform プロパティーとして解釈されます。与えられる"
#~ "と、画像をラップする transform が作成されます(例えば、 pos=(100, 200) を使"
#~ "用して、画像を 100 ピクセル横に、 200 ピクセル縦にオフセットできます)。"

#~ msgid ""
#~ "If the `image` parameter is omitted or None, and the LayeredImage has "
#~ "been given the `image_format` parameter, the image_format is used to "
#~ "generate an image filename."
#~ msgstr ""
#~ "`image` パラメーターが省略されるか None であり、LayerdImage に "
#~ "`image_format` パラメーターが与えられると、 image_format を使用して画像"
#~ "ファイル名を生成します。"

#~ msgid ""
#~ "This is used to represent a layer of an LayeredImage that is controlled "
#~ "by a condition. When the condition is true, the layer is displayed. "
#~ "Otherwise, nothing is displayed."
#~ msgstr ""
#~ "これにより条件で制御される LayerdImage のレイヤーを表します。条件が True "
#~ "ならレイヤーが表示され、そうでなければ表示されません。"

#~ msgid "`condition`"
#~ msgstr "`condition`"

#~ msgid ""
#~ "This should be a string giving a Python condition that determines if the "
#~ "layer is displayed."
#~ msgstr "レイヤーが表示されるかどうかを決定する Python  の条件の文字列です。"

#~ msgid ""
#~ "If not None, this should be a displayable that is displayed when the "
#~ "condition is true."
#~ msgstr "これは None または条件が True なら表示される displayable です。"

#~ msgid ""
#~ "An attribute or list of attributes. The condition is only evaluated if "
#~ "all of these are showing."
#~ msgstr ""
#~ "属性または属性のリストです。これらのすべてがあるときのみ条件は評価されま"
#~ "す。"

#~ msgid ""
#~ "An attribute or list of attributes. If not empty, the condition is only "
#~ "evaluated if any of these are showing."
#~ msgstr ""
#~ "属性または属性のリストです。これらのどれかがあるときのみ条件は評価されま"
#~ "す。"

#~ msgid ""
#~ "An attribute or list of attributes. The condition is only evaluated if "
#~ "none of these are showing."
#~ msgstr ""
#~ "属性または属性のリストです。これらのすべてがないときのみ条件は評価されま"
#~ "す。"

#~ msgid ""
#~ "This is an image-like object that, when shown with the proper set of "
#~ "attributes, shows a displayable created by compositing together the "
#~ "displayables associated with those attribute."
#~ msgstr ""
#~ "これは画像のようなオブジェクトで、適切な属性の組み合わせで表示されると、そ"
#~ "れらの属性と関連付けられた displayable を合成して作成した displayable を表"
#~ "示します。"

#~ msgid "`attributes`"
#~ msgstr "`attributes`"

#~ msgid ""
#~ "This must be a list of Attribute objects. Each Attribute object reflects "
#~ "a displayable that may or may not be displayed as part of the image. The "
#~ "items in this list are in back-to-front order, with the first item "
#~ "further from the viewer and the last closest."
#~ msgstr ""
#~ "これは Attribute オブジェクトのリストです。各 Attribute オブジェクトはその"
#~ "画像の一部として表示され、またはされない displayable を反映します。このリ"
#~ "ストの要素は後ろから前の順となり、プレイヤーから見て最初の要素は遠くに、最"
#~ "後のものは近くになります。"

#~ msgid ""
#~ "A transform or list of transforms that are applied to the displayable "
#~ "after it is parameterized."
#~ msgstr ""
#~ "合成後に displayable に適用される transform または transform のリストで"
#~ "す。"

#~ msgid ""
#~ "The name of the layeredimage. This is used as part of the names of image "
#~ "components."
#~ msgstr "レイヤー画像の名前で、画像要素の名前の一部として使用されます。"

#~ msgid ""
#~ "Sets whether or not the available area is taken into account as for how "
#~ "children are placed and how they are sized (when they have variable "
#~ "size). If False, the available area is considered, and if True it is not. "
#~ "If None, defaults to :var:`config.layeredimage_offer_screen`."
#~ msgstr ""
#~ "子の配置と (可変サイズである場合) サイズ合わせで利用可能な領域を考慮するか"
#~ "どうか設定します。 False であれば利用可能な領域を考慮し、True であれば考慮"
#~ "しません。 None の場合、デフォルトは :var:`config."
#~ "layeredimage_offer_screen` です。"

#~ msgid ""
#~ "Additional keyword arguments may contain transform properties. If any are "
#~ "present, a transform is created that wraps the result image. Remaining "
#~ "keyword arguments are passed to a Fixed that is created to hold the "
#~ "layer. Unless explicitly overridden, xfit and yfit are set to true on the "
#~ "Fixed, which means it will shrink to the smallest size that fits all of "
#~ "the layer images it is showing."
#~ msgstr ""
#~ "追加のキーワード引数には transofrm プロパティーが含められます。与えられれ"
#~ "ば Transorm が作成され結果の画像をラップします。残りのキーワード引数はレイ"
#~ "ヤーを貼り付けるために作成された Fixed に渡されます。明示的な上書きがなけ"
#~ "れば、 xfit と yfit は Fixed で True に設定され、表示している全てのレイ"
#~ "ヤー画像にフィットする最小サイズに縮みます。"

#~ msgid ""
#~ "A LayeredImage is not a displayable, and can't be used in all the places "
#~ "a displayable can be used. This is because it requires an image name "
#~ "(generally including image attributes) to be provided. As such, it should "
#~ "either be displayed through a scene or show statement, or by an image "
#~ "name string used as a displayable."
#~ msgstr ""
#~ "LayerdImage は displayable ではなく、 displayable が使用可能な全ての場所で"
#~ "は使用出来ません。これは (一般的に画像属性を含む) 画像名 の提供が必要なた"
#~ "めです。そういうわけで、 LayerdImage は scene や show ステートメントか、 "
#~ "displayable として使用される画像名の文字列から表示されるべきです。"

#~ msgid "For example::"
#~ msgstr "例 ::"

#~ msgid ""
#~ "If an attribute is not inside a group, it's placed in a group with the "
#~ "same name, but that group is not used to compute the displayable name. "
#~ "(So it would look for \"image_attribute\", not \"image_attribute_attribute"
#~ "\")."
#~ msgstr ""
#~ "属性にグループがなければ、同じ名前のグループに配置されますが、そのグループ"
#~ "は displayable 名の推測に使用されません(つまり \"image_attribute_attribute"
#~ "\" ではなく \"image_attribute\" を探します)。"

#~ msgid "The name of the group."
#~ msgstr "グループの名前です。"
