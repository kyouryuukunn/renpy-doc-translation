# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2020, Tom Rothamel
# This file is distributed under the same license as the Ren'Py Visual Novel Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Ren'Py Visual Novel Engine 7.4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-30 21:47+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/cds.rst:7
msgid "Creator-Defined Statements"
msgstr ""

#: ../../source/cds.rst:9
msgid "Creator-Defined Statements (CDS) allow you to add your own statements to Ren'Py. This makes it possible to add things that are not supported by the current syntax of Ren'Py. CDS are more flexible than the direct Python code. Most often, CDS are used when you have a repeatable construction. For example, calling a function with one argument. Ren'Py does not know what this function does and how it should be executed, so Ren'Py does not do anything with it until execution and has an error if an exception occurs. Using the CDS allows you to check the correctness of the syntax using parse (for example, check that the argument is a valid string), to ignore incorrect data at execution (for non-critical functions, it is better to skip the execute than to throw an exception), predict displayables (if the function uses them), and give you addition information during lint (if at runtime it was ignored you can have a report here). The CDS does not guarantee that the execution will be successful, but the better you code your statement, the better Ren'Py can \"understand\" what you expect from it."
msgstr ""

#: ../../source/cds.rst:24
msgid "Creator-defined statements must be defined in a ``python early`` block. What's more, the filename containing the user-defined statement must be be loaded earlier than any file that uses it. Since Ren'Py loads files in Unicode sort order, it generally makes sense to prefix the name of any file containing a user-defined statement with 01, or some other small number."
msgstr ""

#: ../../source/cds.rst:30
msgid "A creator-defined statement cannot be used in the file in which it is defined."
msgstr ""

#: ../../source/cds.rst:32
msgid "Creator-defined statement are registered using the :func:`renpy.register_statement` function."
msgstr ""

#: ../../source/cds.rst:37
msgid "The parse method takes a Lexer object:"
msgstr ""

#: ../../source/cds.rst:43
msgid "Adds a `msg` (with the current position) in the list of detected parsing errors. This interrupts the parsing of the current statement, but does not prevent further parsing."
msgstr ""

#: ../../source/cds.rst:49
msgid "Tries to parse `thing`, and reports an error if it cannot be done."
msgstr ""

#: ../../source/cds.rst:51
msgid "If `thing` is a string, tries to parse it using :func:`match`. Otherwise, thing must be a other method on this lexer object, which is called without arguments. If `name` is not specified, the name of the method will be used in the message (or `thing` if it's a string), otherwise the `name` will be used."
msgstr ""

#: ../../source/cds.rst:59
msgid "True if the lexer is at the end of the line."
msgstr ""

#: ../../source/cds.rst:63
msgid "If we are not at the end of the line, raise an error."
msgstr ""

#: ../../source/cds.rst:67
msgid "Called to indicate this statement does not expect a block. If a block is found, raises an error. `stmt` should be a string, it will be added to the message with an error."
msgstr ""

#: ../../source/cds.rst:73
msgid "Called to indicate that the statement requires that a non-empty block is present. `stmt` should be a string, it will be added to the message with an error."
msgstr ""

#: ../../source/cds.rst:79
msgid "True if the current line has a non-empty block."
msgstr ""

#: ../../source/cds.rst:83
msgid "Matches an arbitrary regexp string."
msgstr ""

#: ../../source/cds.rst:85
msgid "All of the statements in the lexer that match things are implemented in terms of this function. They first skip whitespace, then attempt to match against the line. If the match succeeds, the matched text is returned. Otherwise, None is returned, and the state of the lexer is unchanged."
msgstr ""

#: ../../source/cds.rst:93
msgid "Matches `s` as a keyword."
msgstr ""

#: ../../source/cds.rst:97
msgid "Matches a name. This does not match built-in keywords."
msgstr ""

#: ../../source/cds.rst:101
msgid "Matches any word, including keywords. Returns the text of the matched word."
msgstr ""

#: ../../source/cds.rst:106
msgid "Matches an image name component. Unlike a word, a image name component can begin with a number."
msgstr ""

#: ../../source/cds.rst:111
msgid "Matches a Ren'Py string."
msgstr ""

#: ../../source/cds.rst:115
msgid "Matches an integer, returns a string containing the integer."
msgstr ""

#: ../../source/cds.rst:119
msgid "Matches a floating point number, returns a string containing the floating point number."
msgstr ""

#: ../../source/cds.rst:124
msgid "Matches a label name, either absolute or relative. If `declare` is true, then the global label name is set. (Note that this does not actually declare the label - the statement is required to do that by returning it from the `label` function.)"
msgstr ""

#: ../../source/cds.rst:131
msgid "Matches a simple Python expression, returns it as a string. This is often used when you expect a variable name. It is not recommended to change the result. The correct action is to evaluate the result in the future."
msgstr ""

#: ../../source/cds.rst:138
msgid "Matches a Python expression that ends in a `delim`, for example ':'. This is often used when you expect a condition until the delimiter. It is not recommended to change the result. The correct action is to evaluate the result in the future. This raises an error if end of line is reached before the delimiter."
msgstr ""

#: ../../source/cds.rst:146
msgid "This must be called before the parentheses with the arguments list, if they are not specified returns None, otherwise returns an object representing the arguments to a function call. This object has an ``evaluate`` method on it that takes an optional `scope` dictionary, and returns a tuple in which the first component is a tuple of positional arguments, and the second component is a dictionary of keyword arguments."
msgstr ""

#: ../../source/cds.rst:156
msgid "Skips whitespace, then returns the rest of the line."
msgstr ""

#: ../../source/cds.rst:160
msgid "Returns an opaque object representing the current state of the lexer."
msgstr ""

#: ../../source/cds.rst:164
msgid "When `o` is the object returned from checkpoint(), reverts the state of the lexer to what it was when checkpoint() was called. (This is used for backtracking.)"
msgstr ""

#: ../../source/cds.rst:170
msgid "Return a Lexer for the block associated with the current line."
msgstr ""

#: ../../source/cds.rst:174
msgid "In a subblock lexer, advances to the next line. This must be called before the first line, so the first line can be parsed. Returns True if we've successfully advanced to a line in the block, or False if we have advanced beyond all lines in the block."
msgstr ""

#: ../../source/cds.rst:181
msgid "When called, this parses the current line as a Ren'Py script statement, generating an error if this is not possible. This method returns an opaque object that can be returned from get_next() or passed to :func:`renpy.jump` or :func:`renpy.call`. This object should not be stored except as part of the parse result of the statement."
msgstr ""

#: ../../source/cds.rst:187
msgid "When the statement returned from this completes, control is transfered to the statement after the creator-defined statement. (Which might be the statement created using post_execute)."
msgstr ""

#: ../../source/cds.rst:193
msgid "This parses all of the remaining lines in the current block as Ren'Py script, and returns a SubParse corresponding to the first statement in the block. The block is chained together such that all statements in the block are run, and then control is transferred to the statement after this creator-defined statement."
msgstr ""

#: ../../source/cds.rst:199
msgid "Note that this parses the current block. In the more likely case that you'd like to parse the subblock of the current statement, the correct way to do that is::"
msgstr ""

#: ../../source/cds.rst:217
msgid "`empty`"
msgstr ""

#: ../../source/cds.rst:215
msgid "If True, allows an empty block to be parsed. (An empty block is equivalent to a block with a single ``pass`` statement.)"
msgstr ""

#: ../../source/cds.rst:218
msgid "If False, an empty block triggers an error."
msgstr ""

#: ../../source/cds.rst:223
msgid "This is a context decorator, used in conjunction with the with statement, that catches and reports lexer errors inside its context block, then continues after the block."
msgstr ""

#: ../../source/cds.rst:227
msgid "Here's an example of how it can be used to report multiple errors in a single subblock. ::"
msgstr ""

#: ../../source/cds.rst:253
msgid "Lint Utility Functions"
msgstr ""

#: ../../source/cds.rst:255
msgid "These functions are useful in writing lint functions."
msgstr ""

#: ../../source/cds.rst:260
msgid "Example"
msgstr ""

#: ../../source/cds.rst:262
msgid "This creates a new statement ``line`` that allows lines of text to be specified without quotes. ::"
msgstr ""

#: ../../source/cds.rst:289
msgid "This can be used by writing::"
msgstr ""

